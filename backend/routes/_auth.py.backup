"""
Authentication Routes - JWT-based auth with support for:
- Email/Password registration and login
- Telegram login
- Wallet connect (MetaMask)
- Token refresh
"""
from fastapi import APIRouter, HTTPException, status, Depends
from pydantic import BaseModel, EmailStr, Field
from typing import Optional
from datetime import datetime, timezone
import uuid
import re

from utils.jwt_auth import (
    hash_password, verify_password, generate_tokens, 
    decode_token, get_current_user_required
)
from utils.telegram_verify import verify_telegram_auth_safe

router = APIRouter(prefix="/auth", tags=["authentication"])


async def get_db():
    """Get database instance"""
    from server import db
    return db


# ========== Request/Response Models ==========

class RegisterRequest(BaseModel):
    username: str = Field(..., min_length=3, max_length=30)
    email: Optional[EmailStr] = None
    password: str = Field(..., min_length=6)
    name: Optional[str] = None
    telegram_id: Optional[str] = None
    wallet_address: Optional[str] = None
    referral_code: Optional[str] = None


class LoginRequest(BaseModel):
    username: str  # Can be username, email, or telegram_id
    password: str


class TelegramLoginRequest(BaseModel):
    telegram_id: str
    telegram_username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    photo_url: Optional[str] = None
    auth_date: int
    hash: str  # Telegram auth hash for verification


class WalletLoginRequest(BaseModel):
    wallet_address: str
    signature: str
    message: str


class RefreshTokenRequest(BaseModel):
    refresh_token: str


class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    user: dict


class UserResponse(BaseModel):
    id: str
    username: str
    email: Optional[str]
    name: Optional[str]
    avatar: Optional[str]
    role: str
    telegram_id: Optional[str]
    wallet_address: Optional[str]
    created_at: str


# ========== Helper Functions ==========

def validate_username(username: str) -> bool:
    """Validate username format"""
    pattern = r'^[a-zA-Z0-9_]{3,30}$'
    return bool(re.match(pattern, username))


async def create_user_profile(db, user_id: str, username: str, name: str = None, avatar: str = None):
    """Create author profile for new user"""
    author_data = {
        "id": user_id,
        "name": name or username,
        "username": username,
        "avatar": avatar,
        "bio": "",
        "followers_count": 0,
        "following_count": 0,
        "podcasts_count": 0,
        "rating": 0,
        "created_at": datetime.now(timezone.utc).isoformat()
    }
    await db.authors.insert_one(author_data)
    return author_data


# ========== Auth Endpoints ==========

@router.post("/register", response_model=TokenResponse)
async def register(request: RegisterRequest):
    """Register a new user with email/password"""
    db = await get_db()
    
    # Validate username
    if not validate_username(request.username):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username must be 3-30 characters, alphanumeric and underscores only"
        )
    
    # Check if username already exists
    existing_user = await db.users.find_one({"username": request.username.lower()})
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already registered"
        )
    
    # Check if email already exists
    if request.email:
        existing_email = await db.users.find_one({"email": request.email.lower()})
        if existing_email:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Email already registered"
            )
    
    # Create user
    user_id = str(uuid.uuid4())
    hashed_password = hash_password(request.password)
    
    user = {
        "id": user_id,
        "username": request.username.lower(),
        "email": request.email.lower() if request.email else None,
        "password_hash": hashed_password,
        "name": request.name or request.username,
        "avatar": None,
        "role": "user",  # user, creator, moderator, admin
        "telegram_id": request.telegram_id,
        "wallet_address": request.wallet_address,
        "referred_by": request.referral_code,
        "is_active": True,
        "is_verified": False,
        "created_at": datetime.now(timezone.utc).isoformat(),
        "last_login": datetime.now(timezone.utc).isoformat()
    }
    
    await db.users.insert_one(user)
    
    # Create author profile
    await create_user_profile(db, user_id, request.username.lower(), request.name)
    
    # Generate tokens
    tokens = generate_tokens(user_id, request.username.lower(), "user")
    
    return {
        **tokens,
        "user": {
            "id": user_id,
            "username": user["username"],
            "email": user["email"],
            "name": user["name"],
            "avatar": user["avatar"],
            "role": user["role"]
        }
    }


@router.post("/login", response_model=TokenResponse)
async def login(request: LoginRequest):
    """Login with username/email and password"""
    db = await get_db()
    
    # Find user by username or email
    user = await db.users.find_one({
        "$or": [
            {"username": request.username.lower()},
            {"email": request.username.lower()}
        ]
    })
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password"
        )
    
    # Verify password
    if not verify_password(request.password, user.get("password_hash", "")):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password"
        )
    
    # Check if user is active
    if not user.get("is_active", True):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Account is disabled"
        )
    
    # Update last login
    await db.users.update_one(
        {"id": user["id"]},
        {"$set": {"last_login": datetime.now(timezone.utc).isoformat()}}
    )
    
    # Generate tokens
    tokens = generate_tokens(user["id"], user["username"], user.get("role", "user"))
    
    return {
        **tokens,
        "user": {
            "id": user["id"],
            "username": user["username"],
            "email": user.get("email"),
            "name": user.get("name"),
            "avatar": user.get("avatar"),
            "role": user.get("role", "user")
        }
    }


@router.post("/telegram-login", response_model=TokenResponse)
async def telegram_login(request: TelegramLoginRequest):
    """Login or register with Telegram"""
    db = await get_db()
    
    # Verify Telegram authentication hash
    bot_token = os.environ.get('TELEGRAM_BOT_TOKEN')
    
    is_valid = verify_telegram_auth_safe(
        telegram_id=request.telegram_id,
        auth_date=request.auth_date,
        hash_value=request.hash,
        bot_token=bot_token,
        first_name=request.first_name,
        last_name=request.last_name,
        username=request.telegram_username,
        photo_url=request.photo_url
    )
    
    if not is_valid:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid Telegram authentication"
        )
    
    # Find existing user by telegram_id
    user = await db.users.find_one({"telegram_id": request.telegram_id})
    
    if user:
        # Update last login and telegram info
        await db.users.update_one(
            {"id": user["id"]},
            {
                "$set": {
                    "last_login": datetime.now(timezone.utc).isoformat(),
                    "telegram_username": request.telegram_username,
                    "avatar": request.photo_url or user.get("avatar")
                }
            }
        )
    else:
        # Create new user
        user_id = str(uuid.uuid4())
        username = request.telegram_username or f"tg_{request.telegram_id}"
        
        # Ensure unique username
        existing = await db.users.find_one({"username": username.lower()})
        if existing:
            username = f"{username}_{str(uuid.uuid4())[:4]}"
        
        name = f"{request.first_name or ''} {request.last_name or ''}".strip() or username
        
        user = {
            "id": user_id,
            "username": username.lower(),
            "email": None,
            "password_hash": None,
            "name": name,
            "avatar": request.photo_url,
            "role": "user",
            "telegram_id": request.telegram_id,
            "telegram_username": request.telegram_username,
            "wallet_address": None,
            "is_active": True,
            "is_verified": True,  # Telegram verified
            "created_at": datetime.now(timezone.utc).isoformat(),
            "last_login": datetime.now(timezone.utc).isoformat()
        }
        
        await db.users.insert_one(user)
        await create_user_profile(db, user_id, username.lower(), name, request.photo_url)
    
    # Generate tokens
    tokens = generate_tokens(user["id"], user["username"], user.get("role", "user"))
    
    return {
        **tokens,
        "user": {
            "id": user["id"],
            "username": user["username"],
            "email": user.get("email"),
            "name": user.get("name"),
            "avatar": user.get("avatar"),
            "role": user.get("role", "user"),
            "telegram_id": user.get("telegram_id")
        }
    }


@router.post("/wallet-login", response_model=TokenResponse)
async def wallet_login(request: WalletLoginRequest):
    """Login or register with crypto wallet (MetaMask)"""
    db = await get_db()
    
    # TODO: Verify wallet signature in production
    # For now, we trust the wallet address
    
    wallet_address = request.wallet_address.lower()
    
    # Find existing user by wallet
    user = await db.users.find_one({"wallet_address": wallet_address})
    
    if user:
        # Update last login
        await db.users.update_one(
            {"id": user["id"]},
            {"$set": {"last_login": datetime.now(timezone.utc).isoformat()}}
        )
    else:
        # Create new user
        user_id = str(uuid.uuid4())
        username = f"wallet_{wallet_address[:8]}"
        
        # Ensure unique username
        existing = await db.users.find_one({"username": username.lower()})
        if existing:
            username = f"{username}_{str(uuid.uuid4())[:4]}"
        
        user = {
            "id": user_id,
            "username": username.lower(),
            "email": None,
            "password_hash": None,
            "name": f"User {wallet_address[:6]}...{wallet_address[-4:]}",
            "avatar": None,
            "role": "user",
            "telegram_id": None,
            "wallet_address": wallet_address,
            "is_active": True,
            "is_verified": True,  # Wallet verified
            "created_at": datetime.now(timezone.utc).isoformat(),
            "last_login": datetime.now(timezone.utc).isoformat()
        }
        
        await db.users.insert_one(user)
        await create_user_profile(db, user_id, username.lower(), user["name"])
    
    # Generate tokens
    tokens = generate_tokens(user["id"], user["username"], user.get("role", "user"))
    
    return {
        **tokens,
        "user": {
            "id": user["id"],
            "username": user["username"],
            "email": user.get("email"),
            "name": user.get("name"),
            "avatar": user.get("avatar"),
            "role": user.get("role", "user"),
            "wallet_address": user.get("wallet_address")
        }
    }


@router.post("/refresh", response_model=TokenResponse)
async def refresh_token(request: RefreshTokenRequest):
    """Refresh access token using refresh token"""
    db = await get_db()
    
    # Decode refresh token
    payload = decode_token(request.refresh_token)
    
    if payload.get("type") != "refresh":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid refresh token"
        )
    
    user_id = payload.get("sub")
    
    # Get user
    user = await db.users.find_one({"id": user_id})
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found"
        )
    
    if not user.get("is_active", True):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Account is disabled"
        )
    
    # Generate new tokens
    tokens = generate_tokens(user["id"], user["username"], user.get("role", "user"))
    
    return {
        **tokens,
        "user": {
            "id": user["id"],
            "username": user["username"],
            "email": user.get("email"),
            "name": user.get("name"),
            "avatar": user.get("avatar"),
            "role": user.get("role", "user")
        }
    }


@router.get("/me")
async def get_current_user_info(current_user: dict = Depends(get_current_user_required)):
    """Get current authenticated user info"""
    db = await get_db()
    
    user = await db.users.find_one({"id": current_user["user_id"]}, {"_id": 0, "password_hash": 0})
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )
    
    return user


@router.post("/logout")
async def logout(current_user: dict = Depends(get_current_user_required)):
    """Logout user (client should discard tokens)"""
    # In a production system, you might want to:
    # - Add token to a blacklist
    # - Clear refresh token from database
    return {"message": "Logged out successfully"}


@router.put("/password")
async def change_password(
    old_password: str,
    new_password: str,
    current_user: dict = Depends(get_current_user_required)
):
    """Change user password"""
    db = await get_db()
    
    user = await db.users.find_one({"id": current_user["user_id"]})
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Verify old password
    if not verify_password(old_password, user.get("password_hash", "")):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid current password"
        )
    
    # Update password
    new_hash = hash_password(new_password)
    await db.users.update_one(
        {"id": current_user["user_id"]},
        {"$set": {"password_hash": new_hash}}
    )
    
    return {"message": "Password changed successfully"}
